# Solidity 知识点

- [Solidity 知识点](#solidity-知识点)
  - [私有、内部、公共和外部函数之间的区别？](#私有内部公共和外部函数之间的区别)
  - [智能合约大小的限制](#智能合约大小的限制)
  - [create 和 create2 之间的区别](#create-和-create2-之间的区别)
  - [Solidity 0.8.0 中的算术运算重大变化](#solidity-080-中的算术运算重大变化)
  - [代理需要哪种特殊的 CALL 才能工作？](#代理需要哪种特殊的-call-才能工作)
  - [在 EIP-1559 之前，如何计算以太坊交易的美元成本？](#在-eip-1559-之前如何计算以太坊交易的美元成本)
  - [在区块链上创建随机数的挑战是什么？](#在区块链上创建随机数的挑战是什么)
  - [荷兰式拍卖和英式拍卖之间有什么区别？](#荷兰式拍卖和英式拍卖之间有什么区别)
  - [ERC20 中的 transfer 和 transferFrom 之间有什么区别？](#erc20-中的-transfer-和-transferfrom-之间有什么区别)
  - [对于地址 allowlist，使用映射还是数组更好？为什么？](#对于地址-allowlist使用映射还是数组更好为什么)
  - [为什么不应该使用 tx.origin 进行身份验证？](#为什么不应该使用-txorigin-进行身份验证)
  - [以太坊主要使用什么哈希函数？](#以太坊主要使用什么哈希函数)
  - [1 个 Ether 相当于 多少个 gwei ？](#1-个-ether-相当于-多少个-gwei-)
  - [1 个 Ether 相当于 多少个 wei ？](#1-个-ether-相当于-多少个-wei-)
  - [assert 和 require 之间有什么区别？](#assert-和-require-之间有什么区别)
  - [闪电贷是什么？](#闪电贷是什么)
  - [检查效果模式（Check-Effects）](#检查效果模式check-effects)
  - [运行独立验证节点所需的最小以太数量是多少？](#运行独立验证节点所需的最小以太数量是多少)
  - [fallback 和 receive 之间有什么区别？](#fallback-和-receive-之间有什么区别)
  - [重入是什么？](#重入是什么)
  - [上海升级后，每个区块的 gas 限制是多少？](#上海升级后每个区块的-gas-限制是多少)
  - [什么阻止无限循环永远运行？](#什么阻止无限循环永远运行)
  - [tx.origin 和 msg.sender 之间有什么区别？](#txorigin-和-msgsender-之间有什么区别)
  - [如何向没有 payable 函数、receive 或回退的合约发送以太？](#如何向没有-payable-函数receive-或回退的合约发送以太)
  - [view 和 pure 之间有什么区别？](#view-和-pure-之间有什么区别)
  - [ERC721 中的 transferFrom 和 safeTransferFrom 之间有什么区别？](#erc721-中的-transferfrom-和-safetransferfrom-之间有什么区别)
  - [如何将 ERC1155 代币转换为非同质化代币？](#如何将-erc1155-代币转换为非同质化代币)
  - [访问控制是什么，为什么重要？](#访问控制是什么为什么重要)
  - [修饰符的作用是什么？](#修饰符的作用是什么)
  - [修饰符的作用是什么？](#修饰符的作用是什么-1)
  - [uint256 可以存储的最大值是多少？](#uint256-可以存储的最大值是多少)
  - [什么是浮动利率和固定利率？](#什么是浮动利率和固定利率)
  - [transfer 和 send 之间有什么区别？为什么不应该使用它们？](#transfer-和-send-之间有什么区别为什么不应该使用它们)
  - [如何在 Solidity 中编写高效的 gas 循环？](#如何在-solidity-中编写高效的-gas-循环)
  - [代理合约中的存储冲突是什么？](#代理合约中的存储冲突是什么)
  - [abi.encode 和 abi.encodePacked 之间有什么区别？](#abiencode-和-abiencodepacked-之间有什么区别)
  - [uint8、uint32、uint64、uint128、uint256 都是有效的 uint 大小。还有其他的吗？](#uint8uint32uint64uint128uint256-都是有效的-uint-大小还有其他的吗)
  - [在权益证明之前后，block.timestamp 发生了什么变化？](#在权益证明之前后blocktimestamp-发生了什么变化)
  - [什么是抢跑（frontrunning）？](#什么是抢跑frontrunning)
  - [什么是提交 - 揭示方案，何时使用它？](#什么是提交---揭示方案何时使用它)
  - [在什么情况下，abi.encodePacked 可能会产生漏洞？](#在什么情况下abiencodepacked-可能会产生漏洞)
  - [以太坊如何确定 EIP-1559 中的 BASEFEE？](#以太坊如何确定-eip-1559-中的-basefee)
  - [冷读（cold read）和热读（warm read）之间有什么区别？](#冷读cold-read和热读warm-read之间有什么区别)
  - [AMM 如何定价资产？](#amm-如何定价资产)
  - [代理中的函数选择器冲突是什么，它是如何发生的？](#代理中的函数选择器冲突是什么它是如何发生的)
  - [payable 函数对 gas 的影响是什么？](#payable-函数对-gas-的影响是什么)
  - [什么是签名重放攻击？](#什么是签名重放攻击)
  - [什么是 gas griefing？](#什么是-gas-griefing)
  - [如何设计一个石头 - 剪刀 - 布的智能合约游戏，使玩家无法作弊？](#如何设计一个石头---剪刀---布的智能合约游戏使玩家无法作弊)
  - [自由内存指针是什么，它存储在哪里？](#自由内存指针是什么它存储在哪里)
  - [接口中有效的函数修饰符有哪些？](#接口中有效的函数修饰符有哪些)
  - [函数参数中的 memory 和 calldata 有什么区别？](#函数参数中的-memory-和-calldata-有什么区别)
  - [描述三种存储 gas 成本类型。](#描述三种存储-gas-成本类型)
  - [为什么可升级合约不应该使用构造函数？](#为什么可升级合约不应该使用构造函数)
  - [UUPS 和 Transparent Upgradeable Proxy 模式之间有什么区别？](#uups-和-transparent-upgradeable-proxy-模式之间有什么区别)
  - [如果合约通过 delegatecall 调用一个空地址或之前已自毁的实现，会发生什么？如果是常规调用而不是 delegatecall 呢？](#如果合约通过-delegatecall-调用一个空地址或之前已自毁的实现会发生什么如果是常规调用而不是-delegatecall-呢)
  - [ERC777 代币存在什么危险？](#erc777-代币存在什么危险)
  - [根据 Solidity 风格指南，函数应该如何排序？](#根据-solidity-风格指南函数应该如何排序)
  - [根据 Solidity 风格指南，函数修饰符应该如何排序？](#根据-solidity-风格指南函数修饰符应该如何排序)
  - [什么是债券曲线（Bonding Curve）？](#什么是债券曲线bonding-curve)
  - [OpenZeppelin ERC721 实现中的 safeMint 与 mint 有何不同？](#openzeppelin-erc721-实现中的-safemint-与-mint-有何不同)
  - [Solidity 提供哪些关键字来测量时间？](#solidity-提供哪些关键字来测量时间)
  - [什么是三明治攻击（Sandwich Attack）？](#什么是三明治攻击sandwich-attack)
  - [如果向一个会回滚的函数进行 delegatecall，delegatecall 会怎么做？](#如果向一个会回滚的函数进行-delegatecalldelegatecall-会怎么做)
  - [乘以和除以二的倍数的 gas 高效替代方法是什么？](#乘以和除以二的倍数的-gas-高效替代方法是什么)
  - [多大 uint 可以与一个地址在一个槽中？](#多大-uint-可以与一个地址在一个槽中)
  - [哪些操作会部分退还 gas？](#哪些操作会部分退还-gas)
  - [ERC165 作用于什么？](#erc165-作用于什么)
  - [如果代理对 A 进行 delegatecall，而 A 执行 address(this).balance，返回的是代理的余额还是 A 的余额？](#如果代理对-a-进行-delegatecall而-a-执行-addressthisbalance返回的是代理的余额还是-a-的余额)
  - [滑点参数有什么用？](#滑点参数有什么用)
  - [ERC721A 如何减少铸造成本？有什么权衡？](#erc721a-如何减少铸造成本有什么权衡)
  - [为什么 Solidity 不支持浮点数运算？](#为什么-solidity-不支持浮点数运算)
  - [什么是 TWAP？](#什么是-twap)
  - [Compound Finance 如何计算利用率？](#compound-finance-如何计算利用率)
  - [定点算术如何表示数字？](#定点算术如何表示数字)
  - [什么是 ERC20 授权抢跑攻击？](#什么是-erc20-授权抢跑攻击)
  - [什么操作码可以实现 `address(this).balance`？](#什么操作码可以实现-addressthisbalance)
  - [一个 Solidity 事件可以有多少个参数？](#一个-solidity-事件可以有多少个参数)
  - [什么是匿名 Solidity 事件？](#什么是匿名-solidity-事件)
  - [在什么情况下，函数可以接收映射作为参数？](#在什么情况下函数可以接收映射作为参数)
  - [ERC4626 中的通胀攻击是什么？](#erc4626-中的通胀攻击是什么)
  - [一个 Solidity 函数可以有多少个参数？](#一个-solidity-函数可以有多少个参数)
  - [`uint64[] x = [1,2,3,4,5]` 使用了多少个存储槽？与内存有何不同？](#uint64-x--12345-使用了多少个存储槽与内存有何不同)
  - [上海升级之前，在什么情况下，`returndatasize()` 比 `push zero` 更有效？](#上海升级之前在什么情况下returndatasize-比-push-zero-更有效)
  - [为什么编译器会在 Solidity 合约中插入 `INVALID` 操作码？](#为什么编译器会在-solidity-合约中插入-invalid-操作码)
  - [自定义错误和带错误字符串的 `require` 在 EVM 层面编码有什么区别？](#自定义错误和带错误字符串的-require-在-evm-层面编码有什么区别)
  - [Compound DeFi 公式中的 `kink` 参数是什么？](#compound-defi-公式中的-kink-参数是什么)
  - [函数名称如何影响 gas 成本，如果有的话？](#函数名称如何影响-gas-成本如果有的话)
  - [ecrecover 存在什么常见漏洞？](#ecrecover-存在什么常见漏洞)
  - [乐观 Rollup 和 zk-rollup 之间有什么区别？](#乐观-rollup-和-zk-rollup-之间有什么区别)
  - [EIP1967 如何选择存储槽，有多少个存储槽，它们代表什么？](#eip1967-如何选择存储槽有多少个存储槽它们代表什么)
  - [1 个 Sazbo 价值多少？](#1-个-sazbo-价值多少)
  - [delegatecall 除了在代理中使用之外还可以用于什么？](#delegatecall-除了在代理中使用之外还可以用于什么)
  - [在什么情况下，一个在以太坊上运行的智能合约在 Polygon 或 Optimism 上无法运行？（假设没有依赖于外部合约）](#在什么情况下一个在以太坊上运行的智能合约在-polygon-或-optimism-上无法运行假设没有依赖于外部合约)
  - [智能合约如何在不更改地址的情况下改变其字节码？](#智能合约如何在不更改地址的情况下改变其字节码)
  - [在循环中将 msg.value 放入有什么危险？](#在循环中将-msgvalue-放入有什么危险)
  - [描述一个函数 `calldata`，该函数接受一个动态长度的 uint128 数组作为参数，当传递 `uint128[1,2,3,4]` 作为参数时会发生什么](#描述一个函数-calldata该函数接受一个动态长度的-uint128-数组作为参数当传递-uint1281234-作为参数时会发生什么)
  - [为什么严格的不相等比较比 ≤ 或 ≥ 更节省 gas？额外的操作码是什么？](#为什么严格的不相等比较比--或--更节省-gas额外的操作码是什么)
  - [如果代理调用一个实现，并且在被调用的函数中实现自毁，会发生什么？](#如果代理调用一个实现并且在被调用的函数中实现自毁会发生什么)
  - [变量作用域和堆栈深度之间有什么关系？](#变量作用域和堆栈深度之间有什么关系)
  - [访问列表交易是什么？](#访问列表交易是什么)
  - [如何使用 mload 操作码终止执行？](#如何使用-mload-操作码终止执行)
  - [在代理的上下文中，什么是信标（beacon）？](#在代理的上下文中什么是信标beacon)
  - [为什么在进行治理投票之前需要对余额进行快照？](#为什么在进行治理投票之前需要对余额进行快照)
  - [如何执行一个不需要用户支付 gas 的交易？](#如何执行一个不需要用户支付-gas-的交易)
  - [在 Solidity 中，不使用汇编，如何获取 calldata 的函数选择器？](#在-solidity-中不使用汇编如何获取-calldata-的函数选择器)
  - [以太坊地址是如何派生的？](#以太坊地址是如何派生的)
  - [什么是元代理标准？](#什么是元代理标准)
  - [如果 try catch 调用一个不会回滚的合约，但在 try 块内发生回滚，会发生什么？](#如果-try-catch-调用一个不会回滚的合约但在-try-块内发生回滚会发生什么)
  - [如果用户调用代理并使代理进行 delegatecall 到 A，A 从其角度来看，msg.sender 是谁？从 B 的角度来看，msg.sender 是谁？从代理的角度来看，msg.sender 是谁？](#如果用户调用代理并使代理进行-delegatecall-到-aa-从其角度来看msgsender-是谁从-b-的角度来看msgsender-是谁从代理的角度来看msgsender-是谁)
  - [为什么大量合约字节码以 6080604052 开头？这个字节码序列是做什么的？](#为什么大量合约字节码以-6080604052-开头这个字节码序列是做什么的)
  - [Uniswap V3 如何确定流动性区间的边界？](#uniswap-v3-如何确定流动性区间的边界)
  - [无风险利率是什么？](#无风险利率是什么)
  - [当一个合约通过 call、delegatecall 或 staticcall 调用另一个合约时，它们之间如何传递信息？](#当一个合约通过-calldelegatecall-或-staticcall-调用另一个合约时它们之间如何传递信息)
  - [内存中的 bytes 和 bytes1\[\] 之间有什么区别？](#内存中的-bytes-和-bytes1-之间有什么区别)
  - [以太坊预编译合约的地址是什么？](#以太坊预编译合约的地址是什么)
  - [当函数数量超过 4 个时，Solidity 如何管理函数选择器？](#当函数数量超过-4-个时solidity-如何管理函数选择器)
  - [如果对一个合约进行委托调用，而该合约又对另一个合约进行委托调用，那么在代理合约、第一个合约和第二个合约中，msg.sender 是谁？](#如果对一个合约进行委托调用而该合约又对另一个合约进行委托调用那么在代理合约第一个合约和第二个合约中msgsender-是谁)
  - [如果有的话，ABI 编码在 calldata 和 memory 之间有何不同？](#如果有的话abi-编码在-calldata-和-memory-之间有何不同)
  - [uint64 和 uint256 在 calldata 中的 ABI 编码有何不同？](#uint64-和-uint256-在-calldata-中的-abi-编码有何不同)
  - [什么是只读重入？](#什么是只读重入)
  - [从不受信任的智能合约调用中读取（内存）字节数组的安全考虑是什么？](#从不受信任的智能合约调用中读取内存字节数组的安全考虑是什么)
  - [如果部署一个空的 Solidity 合约，在区块链上会有什么字节码，如果有的话？](#如果部署一个空的-solidity-合约在区块链上会有什么字节码如果有的话)
  - [以太虚拟机如何定价内存使用？](#以太虚拟机如何定价内存使用)
  - [智能合约的元数据部分存储了什么？](#智能合约的元数据部分存储了什么)
  - [从 MEV 的角度来看，什么是叔块攻击？](#从-mev-的角度来看什么是叔块攻击)
  - [如何进行签名篡改攻击（malleability attack）？](#如何进行签名篡改攻击malleability-attack)
  - [在什么情况下，具有前导零的地址可以节省 gas，以及为什么？](#在什么情况下具有前导零的地址可以节省-gas以及为什么)
  - [payable(msg.sender).call{value: value}("")和 msg.sender.call{value: value}("")之间有什么区别？](#payablemsgsendercallvalue-value和-msgsendercallvalue-value之间有什么区别)
  - [一个字符串占用多少个存储槽？](#一个字符串占用多少个存储槽)
  - [Solidity 编译器中的 --via-ir 功能是如何工作的？](#solidity-编译器中的---via-ir-功能是如何工作的)
  - [函数修饰符是从右到左调用还是从左到右调用，还是不确定的？](#函数修饰符是从右到左调用还是从左到右调用还是不确定的)
  - [如果对一个合约进行委托调用，而执行了指令 CODESIZE，将返回哪个合约的大小？](#如果对一个合约进行委托调用而执行了指令-codesize将返回哪个合约的大小)
  - [为什么 ECDSA 对哈希而不是任意 bytes32 进行签名很重要？](#为什么-ecdsa-对哈希而不是任意-bytes32-进行签名很重要)
  - [描述符号操作测试 (symbolic manipulation testing) 是如何工作的。](#描述符号操作测试-symbolic-manipulation-testing-是如何工作的)
  - [复制内存区域的最有效方式是什么？](#复制内存区域的最有效方式是什么)
  - [如何在链上验证另一个智能合约是否触发了一个事件，而不使用预言机？](#如何在链上验证另一个智能合约是否触发了一个事件而不使用预言机)
  - [当调用 selfdestruct 时，以太何时转移？智能合约的字节码何时被擦除？](#当调用-selfdestruct-时以太何时转移智能合约的字节码何时被擦除)
  - [在什么条件下，OpenZeppelin 的 Proxy.sol 会覆盖自由内存指针？为什么这样做是安全的？](#在什么条件下openzeppelin-的-proxysol-会覆盖自由内存指针为什么这样做是安全的)
  - [为什么 Solidity 废弃了 "years" 关键字？](#为什么-solidity-废弃了-years-关键字)
  - [verbatim 关键字的作用是什么，以及它可以在哪里使用？](#verbatim-关键字的作用是什么以及它可以在哪里使用)
  - [在调用另一个智能合约时可以转发多少 gas？](#在调用另一个智能合约时可以转发多少-gas)
  - [存储 -1 的 int256 变量在十六进制中是什么样子的？](#存储--1-的-int256-变量在十六进制中是什么样子的)
  - [signextend 操作码有什么用？](#signextend-操作码有什么用)
  - [为什么 calldata 中的负数会消耗更多的 gas？](#为什么-calldata-中的负数会消耗更多的-gas)
  - [什么是 zk-friendly 哈希函数，它与非 zk-friendly 哈希函数有何不同？](#什么是-zk-friendly-哈希函数它与非-zk-friendly-哈希函数有何不同)
  - [在零知识的背景下，什么是 nullifier，它的用途是什么？](#在零知识的背景下什么是-nullifier它的用途是什么)
- [智能合约常见攻击方式](#智能合约常见攻击方式)
- [以太坊开发文档](#以太坊开发文档)

## 私有、内部、公共和外部函数之间的区别？

- **私有函数（private）**：仅在合约内部可见，无法被其他合约或外部调用者访问。

- **内部函数（internal）**：与私有函数类似，但允许继承的合约访问。

- **公共函数（public）**：可通过合约内部、继承的合约和外部交易调用。

- **外部函数（external）**：可通过外部交易调用，但不能被合约内部或继承的合约直接调用。

## 智能合约大小的限制

智能合约的大小受区块的 gas 限制约束，目前以太坊的 gas 限制大约为 12.5 万 gas。

## create 和 create2 之间的区别

- **create**：用于创建合约，合约地址与调用者和随机数有关。

- **create2**：允许指定初始种子，以产生相同的合约地址，便于确定性部署。

## Solidity 0.8.0 中的算术运算重大变化

Solidity 0.8.0 引入了溢出和下溢检查，以及 Checked Arithmetic 操作符，提高算术运算的安全性。

## 代理需要哪种特殊的 CALL 才能工作？

代理合约通常使用 `delegatecall` 来调用其他合约，以保留上下文和状态。

## 在 EIP-1559 之前，如何计算以太坊交易的美元成本？

在 EIP-1559 之前，可以通过 Gas Price 乘以 Gas Used 来计算以太坊交易的美元成本。

## 在区块链上创建随机数的挑战是什么？

在区块链上创建真正的随机数面临挑战，因为区块链是公开透明的，无法生成不可预测的随机数。

## 荷兰式拍卖和英式拍卖之间有什么区别？

- **荷兰式拍卖**：价格从高到低逐渐降低，首次有人出价等于或高于当前价格即成交。

- **英式拍卖**：价格从低到高逐渐升高，出价最高的竞拍者成交，出价等于当前最高价。

## ERC20 中的 transfer 和 transferFrom 之间有什么区别？

- **transfer**：从调用者向指定地址转移代币，只需要目标地址。

- **transferFrom**：通过授权，从指定地址向另一地址转移代币。

## 对于地址 allowlist，使用映射还是数组更好？为什么？

使用映射更好，因为在映射中查找地址的时间复杂度是 O(1)，而在数组中是 O(n)。

## 为什么不应该使用 tx.origin 进行身份验证？

`tx.origin` 显示原始调用者，容易受到代理攻击。推荐使用 `msg.sender` 进行身份验证。

## 以太坊主要使用什么哈希函数？

以太坊主要使用 Keccak256（SHA-3 的一种变种）作为哈希函数。

## 1 个 Ether 相当于 多少个 gwei ？

1 Ether 等于 1,000,000,000 gwei。

## 1 个 Ether 相当于 多少个 wei ？

1 Ether 等于 1,000,000,000,000,000,000 wei。

## assert 和 require 之间有什么区别？

- **assert**：用于检查不可能的情况，如果条件不满足，触发异常。

- **require**：用于输入验证，如果条件不满足，终止执行，但不触发异常。

## 闪电贷是什么？

闪电贷是一种在区块链上执行的贷款类型，它允许用户在单个交易中借取资金并立即还款，无需提供任何抵押。这种贷款类型的关键特点是在同一交易内进行借贷和还款，确保贷款的瞬时性。

## 检查效果模式（Check-Effects）

检查效果模式是指在 Solidity 智能合约中执行某个操作前先检查某些效果的一种编程模式。通过在执行状态更改之前进行必要的检查，可以提高合约的安全性和效率。

## 运行独立验证节点所需的最小以太数量是多少？

运行独立验证节点所需的最小以太数量取决于网络和验证节点软件的要求。一般来说，独立验证节点需要足够的以太来支付运行节点所需的 gas 费用，确保节点可以参与网络的共识过程。具体的最小以太数量可能因不同网络而异。

## fallback 和 receive 之间有什么区别？

- **fallback 函数**：在合约接收以太币时触发的函数。如果合约没有实现 `receive` 函数，而发送者没有调用任何函数，则会执行 `fallback` 函数。

- **receive 函数**：Solidity 0.6.0 版本引入的接收以太币的特殊函数。当合约接收以太币时，如果存在 `receive` 函数，则会执行该函数，否则会执行 `fallback` 函数。

## 重入是什么？

重入是一种攻击模式，其中恶意合约利用合约调用合约的递归性质，尝试在同一调用栈上多次执行某个函数。这可能导致合约无法正确处理状态更改，从而导致不安全的行为。

## 上海升级后，每个区块的 gas 限制是多少？

截至我的知识截止日期（2022 年 1 月），Shanghai 升级中没有明确规定每个区块的 gas 限制。以太坊的 gas 限制通常在不同的网络升级中进行调整，而具体的限制值可能取决于网络的需求和升级中的改变。

## 什么阻止无限循环永远运行？

在以太坊上，每次循环执行都会消耗一定数量的 gas。如果 gas 耗尽，循环将被中断，从而防止无限循环永远运行。这是为了防止恶意合约占用过多计算资源。

## tx.origin 和 msg.sender 之间有什么区别？

- **tx.origin**：表示发起交易的外部账户地址。在合约中使用 `tx.origin` 不安全，因为它可能受到身份欺骗攻击。

- **msg.sender**：表示当前调用的合约或外部账户的地址。通常更安全，因为它表示当前执行上下文中的实际调用者。

## 如何向没有 payable 函数、receive 或回退的合约发送以太？

如果合约没有 payable 函数、receive 函数或回退函数，直接向其发送以太是不可行的。这样的合约无法接收以太币，任何尝试发送的交易都会失败。

## view 和 pure 之间有什么区别？

- **view 函数**：表示该函数不会修改合约状态，但可能会读取合约的存储状态。调用 view 函数不会产生 gas 消耗。

- **pure 函数**：表示该函数既不会修改合约状态，也不会读取合约的存储状态。调用 pure 函数不会产生 gas 消耗。

## ERC721 中的 transferFrom 和 safeTransferFrom 之间有什么区别？

- **transferFrom**：是 ERC721 标准中定义的基本的转移函数，它只执行基本的代币转移操作，没有进行接收合约的检查。

- **safeTransferFrom**：是 ERC721 标准中引入的增强函数，它在执行代币转移之前会调用接收合约的 `onERC721Received` 函数，以确保接收合约能够处理代币。

## 如何将 ERC1155 代币转换为非同质化代币？

ERC1155 是一种支持多个代币标识的代币标准，而非同质化代币（NFT）通常是 ERC721 标准的代表。要将 ERC1155 转换为 NFT，可以采用以下步骤：

1. 选择 ERC1155 合约中的一个特定 ID。
2. 针对选定的 ID，创建一个新的 ERC721 合约。
3. 编写将 ERC1155 中的特定 ID 转移到新 ERC721 合约的迁移函数。

## 访问控制是什么，为什么重要？

访问控制是一种通过确定谁有权访问系统、合约或资源来管理和限制访问的机制。在以太坊智能合约中，访问控制是确保只有授权用户或合约可以执行特定操作的关键方面。这对于保护合约的安全性和防止未经授权的访问至关重要。

## 修饰符的作用是什么？

修饰符是 Solidity 中一种用于修改函数行为的功能。它允许在函数执行之前或之后执行额外的代码。修饰符通

## 修饰符的作用是什么？

修饰符是 Solidity 中的一种功能，用于在函数执行前或执行后对函数进行修改或添加一些额外的逻辑。修饰符可以帮助提高代码的可重用性，减少冗余，以及实现对函数行为的可插拔扩展。通过在函数定义中使用修饰符，可以使代码更加清晰和易于维护。

## uint256 可以存储的最大值是多少？

`uint256` 是 Solidity 中用于表示无符号整数的数据类型，它可以存储的最大值是 2^256 - 1，即 115792089237316195423570985008687907853269984665640564039457584007913129639935。这是因为 `uint256` 是一个 256 位的整数，可以表示的最大二进制数是 256 位全为 1。

## 什么是浮动利率和固定利率？

- **浮动利率**：浮动利率是根据市场利率的变化而调整的利率。它随着市场条件的波动而变化，通常与某个基准利率或指数相关联。在借贷或金融领域，借款人的利率可能在一段时间内上升或下降，取决于市场上的实际利率。

- **固定利率**：固定利率是在合同签订时确定并在整个贷款期间保持不变的利率。借款人在整个贷款期间支付相同的利率，不受市场利率波动的影响。这提供了对未来还款的可预测性，但可能导致在某些市场条件下支付较高的利息。

抱歉出现了错误，让我检查并提供正确的回答。

## transfer 和 send 之间有什么区别？为什么不应该使用它们？

- **transfer 和 send 区别：**
  - `transfer` 和 `send` 是用于向地址发送以太币的两个函数。
  - `transfer` 和 `send` 都是低级操作，用于发送较小的金额，并且在失败时会触发异常。
  - 主要区别在于 `send` 返回一个布尔值，表示是否发送成功，而 `transfer` 在失败时会抛出异常。
- **为什么不应该使用它们：**
  - 这些函数在发送失败时不提供明确的错误处理机制，而是通过布尔值或异常，容易引发潜在的安全问题。
  - 推荐使用 `address.call{value: amount}("")` 这种更为灵活、提供详细错误信息的方式来处理转账操作。

## 如何在 Solidity 中编写高效的 gas 循环？

在 Solidity 中编写高效的 gas 循环需要注意以下几点：

- 避免循环中的存储更改：减少对存储的写入操作，优先选择在循环外部进行存储更改。
- 使用 `view` 或 `pure` 关键字：如果循环内部不修改状态，将函数标记为 `view` 或 `pure` 可以帮助编译器进行优化。
- 尽量减少计算和逻辑：简化循环内的计算和逻辑操作，减少 gas 消耗。
- 考虑批量操作：如果可能的话，将多个操作合并成一个批量操作，减少循环次数。

## 代理合约中的存储冲突是什么？

在代理合约中，存储冲突指的是当代理合约和被代理的合约在相同的存储位置上都有数据，并且它们的存储操作发生冲突时的情况。由于代理合约和实现合约可能都尝试对相同的存储位置进行写入，可能导致数据不一致或意外的行为。

解决存储冲突的方法包括使用不同的存储空间，确保代理和实现合约在存储操作时不会相互干扰，或者采用更复杂的存储模式，如使用委托代理。

## abi.encode 和 abi.encodePacked 之间有什么区别？

- **abi.encode：**

  - `abi.encode` 用于将参数编码为紧凑的字节数组。
  - 会包含参数的类型信息，生成的字节数组更大。
  - 适用于将参数传递给函数调用或创建复杂的数据结构。

- **abi.encodePacked：**
  - `abi.encodePacked` 用于将参数按顺序打包，生成紧凑的字节数组。
  - 不包含参数的类型信息，生成的字节数组相对较小。
  - 适用于创建紧凑的数据结构，如用于哈希计算。

选择使用哪个取决于具体的使用场景和需求。

## uint8、uint32、uint64、uint128、uint256 都是有效的 uint 大小。还有其他的吗？

在 Solidity 中，除了上述提到的 `uint8`、`uint32`、`uint64`、`uint128`、`uint256` 外，还有其他有效的 `uint` 大小，如 `uint16`、`uint40`、`uint72` 等。这些类型是根据位数来命名的，表示可以存储的比特位数。

## 在权益证明之前后，block.timestamp 发生了什么变化？

在权益证明（Proof of Stake，PoS）之前，`block.timestamp` 表示区块的时间戳，代表该区块被矿工创建的时间。然而，在权益证明之后，`block.timestamp` 仍然表示相同的概念，即区块的时间戳，用于记录区块的创建时间。

权益证明改变了共识机制，但未改变区块中的时间戳的含义。因此，`block.timestamp` 仍然是指该区块的创建时间。

## 什么是抢跑（frontrunning）？

抢跑是指在区块链上的交易执行之前，有人在事先知道的信息基础上，迅速提交比其他交易更高 gas 价格的交易，从而抢占区块中的交易顺序或执行先机。

在 DeFi 等场景中，抢跑可能导致恶意行为，例如在执行交易前获取有利的价格或执行交易顺序的控制。这种行为可能对其他参与者产生不公平影响，因此抢跑是一个需要解决的问题。

## 什么是提交 - 揭示方案，何时使用它？

提交 - 揭示方案是一种协议设计模式，通常用于加密竞拍等场景。在这种方案中，参与者首先提交加密的信息（通常是秘密出价或策略），然后在揭示阶段公开这些信息。

**使用场景：**

- **加密竞拍：** 在拍卖中，参与者首先提交加密的出价，然后在揭示阶段公开他们的出价，以确定最高出价者。

**优势：**

- 避免了信息的逐步泄露，确保所有参与者在揭示阶段同时公开他们的信息。

## 在什么情况下，abi.encodePacked 可能会产生漏洞？

使用 `abi.encodePacked` 时需要小心，因为它不会在参数之间添加分隔符或填充，可能导致一些安全漏洞。例如，在构建动态数组时，如果数组中的元素是用户提供的，且长度没有进行验证，可能会导致漏洞。

例如，考虑以下情况：

```solidity
abi.encodePacked(userInputArray)
```

如果 `userInputArray` 的长度由用户控制，用户可以通过提供不同长度的输入数组来影响最终的编码结果，从而可能导致漏洞。

## 以太坊如何确定 EIP-1559 中的 BASEFEE？

在 EIP-1559 中，`BASEFEE` 是动态调整的基础手续费，由区块中的交易需求和区块大小来确定。具体而言，`BASEFEE` 的计算涉及到基本规则和机制：

- 当区块中的交易需求上升时，`BASEFEE` 会增加，以鼓励矿工包含更多的交易。
- 当交易需求下降时，`BASEFEE` 会减少，以防止手续费过高。
- 矿工可以通过在区块中包含更多的交易来增加收入，但不能操纵 `BASEFEE`。

`BASEFEE` 的具体计算方法涉及到区块中的交易量和大小，是通过对当前区块和之前区块的信息进行复杂的算法来实现的。

## 冷读（cold read）和热读（warm read）之间有什么区别？

- **冷读（Cold Read）：**

  - 在区块链中，冷读指的是对不常访问的数据进行读取。例如，首次读取某个合约状态变量或从外部合约获取数据都可能属于冷读。
  - 冷读可能涉及更高的 gas 成本，因为需要从存储中加载数据。

- **热读（Warm Read）：**
  - 热读是对之前已经读取过的数据再次进行读取。如果之前已经读取过某个状态变量，再次读取相同的变量可以被认为是热读。
  - 热读可能有更低的 gas 成本，因为某些数据可能被缓存，可以更快速地访问。

了解数据的冷热读特性有助于更有效地设计合约和减少 gas 成本。

## AMM 如何定价资产？

自动做市商（AMM）使用一种称为恒定乘积公式的机制来定价资产。常见的 AMM 包括 Uniswap 和 Sushiswap。

**恒定乘积公式：**
对于一个包含两种资产的 AMM 池，其资产 X 和 Y 的数量的乘积保持不变，即 `X * Y = K`。

- 当有人在池中进行交易时，他们会将一种资产交换成另一种，导致其中一种资产的数量增加，而另一种数量减少。
- 交易的价格由恒定乘积公式确定，即当前池中两种资产的数量关系。

这种机制保证了交易的无滑点性质，但也可能导致价格对交易规模敏感，尤其是在资金池较小时。

## 代理中的函数选择器冲突是什么，它是如何发生的？

函数选择器冲突是指在代理合约中，当多个被代理的合约中存在相同的函数选择器（函数签名）时可能发生的情况。函数选择器是用于唯一标识函数的标识符。

**发生方式：**

1. 多个实现合约中存在相同的函数。
2. 代理合约通过委托调用将调用传递给其中一个实现合约。

**问题：**

- 如果多个实现合约有相同的函数选择器，代理合约在调用时可能无法正确确定应该委托给哪个实现合约，导致函数选择器冲突。

**解决方式：**

- 在设计代理合约时，需要确保被代理的实现合约中没有相同的函数选择器，或者通过其他机制确保正确的委托。

## payable 函数对 gas 的影响是什么？

在 Solidity 中，`payable` 关键字用于声明一个函数可以接受以太币。对于 payable 函数，它可以接收发送给合约的以太币，并且可以执行一些操作或状态更改。

**影响：**

1. **接收以太币：** payable 函数可以接收调用者发送的以太币。
2. **Gas 消耗：** payable 函数的执行会消耗 gas，包括对状态的修改、事件的触发等。
3. **转账和转发：** payable 函数中可以使用 `address.transfer` 或 `address.send` 向其他地址转账以太币，或者使用 `msg.sender.call{value: amount}("")` 进行更复杂的调用。

注意在 payable 函数中处理接收的以太币时要小心防范重入攻击等安全问题。

## 什么是签名重放攻击？

签名重放攻击是一种安全漏洞，发生在区块链中，特别是涉及到消息签名的场景。攻击者通过记录和再次广播有效签名，试图欺骗合约或系统，以重复执行特定的操作。

\*\*攻

击过程：\*\*

1. 攻击者截获有效签名的消息。
2. 攻击者在未经修改的情况下重新广播相同的消息，使用相同的签名。

**防范措施：**

- 使用一次性的标记（nonce）或其他手段确保签名不能被重复使用。
- 避免在没有适当验证的情况下接受相同签名的消息。

## 什么是 gas griefing？

Gas griefing 是一种攻击，旨在通过使交易成本变得极高，阻止其他用户正常使用区块链网络。这通常涉及到意图使交易变得非常昂贵，使得用户不愿或无法执行特定的操作。

**示例：**

- 在合约中故意设计使得某些操作的 gas 成本非常高，然后攻击者发送包含这些操作的交易，导致其他用户在尝试执行这些操作时需要支付高昂的 gas 费用。

**防范措施：**

- Solidity 中可以使用 `gasleft()` 函数来检查剩余 gas，并根据需要进行适当的处理，例如避免执行昂贵的操作或调整 gas 价格。

## 如何设计一个石头 - 剪刀 - 布的智能合约游戏，使玩家无法作弊？

为了确保玩家无法作弊，可以使用以下步骤：

1. **玩家提交加密的动作：** 玩家通过合约提交其选择的动作的加密哈希，使用特定的算法，例如 keccak256。

2. **揭示动作：** 等待所有玩家提交后，再要求他们揭示原始动作。这一步确保在动作选择之前没有信息泄露。

3. **验证动作：** 合约验证揭示的原始动作是否与之前提交的加密哈希匹配。如果匹配，则视为有效的动作。

4. **确定胜负：** 根据石头 - 剪刀 - 布的规则，在合约中确定每轮的胜者和输家，并分配奖励。

## 自由内存指针是什么，它存储在哪里？

自由内存指针是 Solidity 中的一个特殊指针，用于表示可用于动态分配内存的位置。它存储在 `0x40` 的位置，被称为 "free memory pointer" 或 "free memory pointer slot"。在 Solidity 中，动态分配内存时，自由内存指针将指向当前可用的内存位置。通过递增自由内存指针的值，可以在内存中分配新的空间。

## 接口中有效的函数修饰符有哪些？

在接口中，函数声明只包含函数签名，不包括实际实现，因此修饰符在接口中没有实际作用。接口中的函数修饰符没有意义，因为接口本身不能包含实际的代码。

- external：指定函数只能从合约外部调用。
- view：指定函数不会修改合约状态。
- pure：指定函数既不会修改合约状态，也不会读取合约状态。
- payable：指定函数可以接受以太币作为支付。

private 和 internal 不可用，public 可用，但是效果等同于 external。

## 函数参数中的 memory 和 calldata 有什么区别？

- **memory：** 用于声明在函数执行期间临时存储数据的位置，主要用于复杂的数据类型（如数组、字符串等）。在函数调用结束后，内存中的数据将被清除。

- **calldata：** 用于声明在函数调用期间传递的数据，主要用于外部函数调用。Calldata 是只读的，且其数据在函数执行结束后不会被改变。

## 描述三种存储 gas 成本类型。

1. **磁盘存储（Storage）：** 操作存储在区块链上，具有最高的 gas 成本。写入或修改存储变量都需要较高的 gas。

2. **内存（Memory）：** 用于在函数执行期间存储临时数据，gas 成本较存储低。内存中的数据在函数执行结束后会被清除。

3. **栈（Stack）：** 用于存储基本数据类型和局部变量，gas 成本最低。栈上的数据在函数执行结束后会被清除。

## 为什么可升级合约不应该使用构造函数？

可升级合约不应该使用构造函数，因为构造函数只会在合约部署时执行一次。当使用升级合约时，新的合约部署不会执行构造函数，这可能导致合约状态不正确或缺少必要的初始化。应该使用特定的初始化函数来替代构造函数，并确保在每次合约升级时都调用这个初始化函数。

## UUPS 和 Transparent Upgradeable Proxy 模式之间有什么区别？

UUPS（Universal Upgradeable Proxy Standard）是一种升级合约的标准，而 Transparent Upgradeable Proxy 模式是 UUPS 的一种实现。UUPS 提供了一种统一的方式来处理合约升级，而 Transparent Upgradeable Proxy 则是其中的一种实现方式，通过使用委托调用将调用路由到升级后的合约。

## 如果合约通过 delegatecall 调用一个空地址或之前已自毁的实现，会发生什么？如果是常规调用而不是 delegatecall 呢？

- **delegatecall：** 如果通过 delegatecall 调用一个空地址或已自毁的合约实现，调用合约的上下文将保持不变，但调用的代码将是空地址或已自毁的合约的代码。这可能导致执行的行为与预期不符，但不会中断主调用合约的执行。

- **常规调用：** 如果通过常规调用（call）调用一个空地址或已自毁的合约实现，调用会失败，并且可能触发异常。这是因为在常规调用中，调用上下文会改变，而调用的代码不存在或已被销毁，导致调用失败。

## ERC777 代币存在什么危险？

ERC777 代币的一个潜在危险是复杂性。相较于 ERC20，ERC777 引入了更多功能，例如操作符和回调，这可能使合约变得更加复杂和难以理解。这增加了引入错误或安全漏洞的风险。此外，由于 ERC777 是较新的标准，可能还存在一些未被发现或理解的潜在问题。

## 根据 Solidity 风格指南，函数应该如何排序？

根据 Solidity 风格指南，函数应该按照可见性（public、external、internal、private）和状态修改器（view、pure、payable）进行排序。一般来说，函数的顺序应该是从可见性最高、状态修改器最轻的函数开始，逐渐变为可见性更低、状态修改器更重的函数。这有助于提高代码的可读性和可维护性。

## 根据 Solidity 风格指南，函数修饰符应该如何排序？

函数修饰符的排序通常按照它们的目的和对函数的影响进行。一般来说，可见性修饰符（public、external、internal、private）应该排在前面，然后是状态修改器（view、pure、payable），最后是自定义修饰符。这样的排序有助于更清晰地了解函数的行为。

## 什么是债券曲线（Bonding Curve）？

债券曲线是一种数学模型，描述了代币的价格如何随着供应量的变化而变化。在区块链中，债券曲线通常用于实现代币的发行和销售机制。这种曲线可以是线性的，也可以是其他形式，例如指数曲线或自定义曲线。通过债券曲线，可以调整代币的价格以响应供需关系，促使市场在代币发行和交易中达到平衡。

## OpenZeppelin ERC721 实现中的 safeMint 与 mint 有何不同？

在 OpenZeppelin 的 ERC721 实现中，`safeMint` 与 `mint` 的主要区别在于安全性。`safeMint` 函数会在执行代币铸造操作后，检查接收者是否实现了 ERC721 的接口（`onERC721Received`），以确保接收者是合法的 ERC721 代币接收合约。这是一种增加交互安全性的做法，避免将代币发送到无法处理的地址。

## Solidity 提供哪些关键字来测量时间？

Solidity 提供 `block` 对象来测量时间。以下是两个常用的关键字：

- `block.timestamp`：当前区块的时间戳，表示为 Unix 时间（秒）。
- `block.number`：当前区块的块号。

这些关键字可用于在智能合约中进行时间相关的逻辑和计算。

## 什么是三明治攻击（Sandwich Attack）？

三明治攻击是一种针对去中心化交易所（DEX）的攻击方式。攻击者在区块链网络中提前查看即将发生的交易，并在合适的时机插入自己的交易。这样的攻击可以导致操纵价格或窃取交易者的利润。为防范这种攻击，交易者应该谨慎使用去中心化交易所，并在可能的情况下避免在高波动性时段进行交易。

## 如果向一个会回滚的函数进行 delegatecall，delegatecall 会怎么做？

如果向一个会回滚的函数进行 `delegatecall`，调用者合约的状态将会被修改，但在调用结束时，所有的状态变化都会被撤销，就好像调用失败一样。这是因为 `delegatecall` 执行代码的上下文（包括状态变量和存储）与调用者相同，但是在执行结束后，任何状态的更改都会被还原，以保护调用者不受调用合约的影响。

## 乘以和除以二的倍数的 gas 高效替代方法是什么？

在 Solidity 中，将数值乘以或除以二的倍数可以通过位操作来实现，这比乘法和除法运算更为高效。例如：

- 乘以二的倍数：`x << n`，其中 `n` 是要左移的位数。
- 除以二的倍数：`x >> n`，其中 `n` 是要右移的位数。

这些位操作通常比相应的乘法和除法更快，尤其在大整数上。

## 多大 uint 可以与一个地址在一个槽中？

在 Solidity 中，一个槽（slot）的大小是 256 位。因此，一个 `uint` 变量和一个地址可以放入同一个槽中，因为它们的大小加在一起不超过 256 位。例如：

```solidity
contract Example {
    uint256 public myUint;
    address public myAddress;
}
```

在这个例子中，`myUint` 和 `myAddress` 可以放入合同的同一存储槽。

## 哪些操作会部分退还 gas？

在以太坊中，部分操作会导致 gas 的退还。其中包括：

- **SSTORE 操作（状态存储变更）：** 当将一个非零值写入存储槽，并且之前的值是零，会有一部分 gas 被退还。
- **SELFDESTRUCT 操作（自毁）：** 当一个合约自毁时，将会退还余下的 gas。

## ERC165 作用于什么？

ERC165 是用于标准化合约接口的接口标准。它规定了一种方式，通过该方式合约可以声明其是否支持某个特定的接口。合约通过实现 `supportsInterface` 函数，返回特定的接口标识符（interface ID）来表明其支持的接口。

## 如果代理对 A 进行 delegatecall，而 A 执行 address(this).balance，返回的是代理的余额还是 A 的余额？

在这种情况下，A 执行 `address(this).balance` 时返回的是代理合约的余额，而不是 A 的余额。delegatecall 会在代理上下文中执行代码，因此 `address(this)` 指向的是代理合约地址。

## 滑点参数有什么用？

在去中心化交易所（DEX）中，滑点是指市场价格在用户提交订单和实际执行之间的波动。滑点参数用于设置用户愿意接受的最大价格波动，防止在订单执行过程中出现意外的大幅度价格变动。

## ERC721A 如何减少铸造成本？有什么权衡？

ERC721A 是指对 ERC721 标准的一种改进，其中 "A" 代表 "Atomic"。它通过引入原子铸造（Atomic Minting）的概念，减少了铸造（Minting）操作的成本。原子铸造是指将新代币的所有权直接分配给接收者，而无需中间步骤。

权衡方面，原子铸造可能增加了合约的复杂性，因为需要确保原子性和安全性，但它可以提高铸造操作的效率。

## 为什么 Solidity 不支持浮点数运算？

Solidity 不支持浮点数运算主要是因为 EVM（以太坊虚拟机）是为整数运算而设计的，浮点数运算会引入复杂性和不确定性，容易导致精度问题。由于智能合约需要在所有节点上执行相同的计算，浮点数的精度和舍入行为可能因执行环境而异，因此 Solidity 选择避免引入这样的不确定性。

## 什么是 TWAP？

TWAP 是时间加权平均价格（Time-Weighted Average Price）的缩写。它是一种计算资产价格的方法，通过在一定时间范围内对价格进行加权平均，降低了瞬时价格波动的影响。TWAP 常用于金融领域，特别是在加密货币领域的定价和交易中。

## Compound Finance 如何计算利用率？

在 Compound Finance 中，利用率是指借贷市场中借款资产的实际借出比例。计算方式为实际借出资产总额除以可借出资产总额。Compound 使用市场的供求关系和利用率来动态调整利率，以维持市场平衡。

---

## 定点算术如何表示数字？

在定点算术中，数字被表示为整数，并通过指定一个固定的小数点位置来表示小数部分。通常，一个整数表示的是实际值乘以某个固定的倍数。例如，如果使用 8 位固定小数点表示，整数 `12345678` 可以被解释为 `123.45678`。

## 什么是 ERC20 授权抢跑攻击？

ERC20 授权抢跑攻击是一种攻击方式，利用 ERC20 标准中的 `approve` 和 `transferFrom` 两个函数，攻击者通过在授权期间快速执行多次交易，可能导致不当的资金转移。为了防范这种攻击，可以使用 ERC20 的改进标准，如 ERC20 Approve and Call 或使用更安全的代币标准，如 ERC777。

## 什么操作码可以实现 `address(this).balance`？

`address(this).balance` 可以通过使用操作码 `EXTBALANCE` 来实现。具体来说，`EXTBALANCE` 操作码获取指定地址（在这里是合约自身）的余额。

## 一个 Solidity 事件可以有多少个参数？

在 Solidity 中，一个事件最多可以有三个匿名参数和多达数十个非匿名参数。匿名参数可以在合约中监听事件时省略名字，非匿名参数需要在事件定义中指定名字。

## 什么是匿名 Solidity 事件？

匿名 Solidity 事件是指在事件定义中没有明确命名的参数。匿名事件参数在触发事件时不会在日志中显示名字，只显示对应的值。这在一些情况下可以提高合约的效率，但在事件监听时需要注意参数的顺序。

## 在什么情况下，函数可以接收映射作为参数？

在 Solidity 中，函数不能直接接收映射作为参数，因为映射类型是不可复制的。函数参数必须是可复制的数据类型，而映射是一种动态大小的数据结构。可以通过将映射的键和值作为独立的参数传递，或者通过结构体包装映射。

## ERC4626 中的通胀攻击是什么？

ERC4626（现在的 ERC20 标准）中的通胀攻击是指合约在发行代币时，通过在发行时无限循环分发代币，导致攻击者无限获得代币。为了防范这种攻击，新的 ERC20 标准通常使用 `totalSupply` 来记录总发行量，并避免无限循环分发。

## 一个 Solidity 函数可以有多少个参数？

Solidity 中一个函数最多可以有 16 个参数。

## `uint64[] x = [1,2,3,4,5]` 使用了多少个存储槽？与内存有何不同？

这个声明使用了一个存储槽，因为它是在存储（即合约的永久状态）中分配的。与内存不同，存储是永久保存在区块链上的，并且每个存储槽都有相应的永久存储成本。内存是临时的，每次函数调用都会重新分配。

## 上海升级之前，在什么情况下，`returndatasize()` 比 `push zero` 更有效？

在上海升级之前，`returndatasize()` 与 `push zero` 相比在某些情况下更有效的一种情况是在动态数组大小未知的情况下。`returndatasize()` 可以获取返回数据的大小，适用于动态数组的情况，而 `push zero` 在这种情况下会更复杂。

## 为什么编译器会在 Solidity 合约中插入 `INVALID` 操作码？

编译器在 Solidity 合约中插入 `INVALID` 操作码是为了处理合约自毁（self-destruct）的情况。当合约自毁时，`INVALID` 操作码会被插入到合约代码中，以确保后续对合约的调用会失败，避免潜在的安全问题。

## 自定义错误和带错误字符串的 `require` 在 EVM 层面编码有什么区别？

自定义错误和带错误字符串的 `require` 在 EVM 层面编码的主要区别是 gas 消耗。自定义错误通常是由合约开发者提供的错误标识符，而带错误字符串的 `require` 会消耗更多 gas，因为它需要将错误字符串编码到合约中，

增加了字节码的大小。

## Compound DeFi 公式中的 `kink` 参数是什么？

在 Compound DeFi 公式中，`kink` 参数是指一个阈值，当借款利率低于这个阈值时，市场的供应量和借款量之间的关系是线性的。当借款利率高于 `kink` 时，市场会更快地减小供应量，以保持平衡。

## 函数名称如何影响 gas 成本，如果有的话？

在 Solidity 中，函数的名字不直接影响 gas 成本。实际上，函数的 gas 成本主要取决于函数的操作、循环、存储读写等复杂度。函数名字的长度相对较小，对整体 gas 成本的影响通常可以忽略。

## ecrecover 存在什么常见漏洞？

`ecrecover` 的常见漏洞之一是与椭圆曲线签名相关的问题。如果签名不是按照规范进行，或者在验签时没有进行足够的检查，可能导致恶意利用。一些漏洞可能涉及到签名的 r、s、v 参数的处理不当，或者在使用 `ecrecover` 时未正确验证签名是否来自合法的地址。

## 乐观 Rollup 和 zk-rollup 之间有什么区别？

- **乐观 Rollup：** 使用链上的智能合约作为主链，通过在链上提交交易数据和状态更新，但不执行实际计算。计算发生在链下，交易只在链上提交执行结果。在发生争议时，可以通过链上合约执行争议解决。

- **zk-rollup：** 使用零知识证明（Zero-Knowledge Proofs）来证明交易的有效性，同时不公开交易的具体内容。这允许在主链上提交的数据更少，因为验证可以在链下完成。zk-rollup 提供更高的隐私和扩展性，但构建和验证证明可能更为复杂。

## EIP1967 如何选择存储槽，有多少个存储槽，它们代表什么？

EIP1967 提供了一个标准，定义了代理合约通过存储槽来管理实现合约的存储数据。选择存储槽通常由实现合约来决定。存储槽的数量取决于合约的设计，可能会有多个存储槽，每个槽用于存储不同类型的数据。这种方式允许代理合约更灵活地与实现合约进行交互，而不会发生存储冲突。

## 1 个 Sazbo 价值多少？

"Sazbo" 并非通用的货币或标准单位，因此无法确定其价值。请提供更多上下文或相关信息以便回答。

## delegatecall 除了在代理中使用之外还可以用于什么？

`delegatecall` 不仅可用于代理模式中，还可以用于合约库的升级。通过 `delegatecall`，一个合约可以调用另一个合约的代码，而调用方的存储和上下文将被保留。这使得在不改变合约地址的情况下，升级合约的代码成为可能。

## 在什么情况下，一个在以太坊上运行的智能合约在 Polygon 或 Optimism 上无法运行？（假设没有依赖于外部合约）

如果一个智能合约没有使用与 EVM 兼容的操作码或依赖于以太坊主网的特定功能，可能无法直接在 Polygon 或 Optimism 等 Layer 2 网络上运行。不同网络之间的差异、协议变更或者底层基础设施的不同可能导致智能合约在其他链上无法正常工作。

## 智能合约如何在不更改地址的情况下改变其字节码？

通过代理模式，智能合约可以在不更改自身地址的情况下改变其字节码。代理合约包含逻辑合约的地址，并通过 `delegatecall` 执行逻辑合约的代码。这样，在升级时，只需在代理合约中更新逻辑合约地址即可，而不必改变代理合约的地址。

## 在循环中将 msg.value 放入有什么危险？

在循环中处理 `msg.value` 可能导致无法预测的结果。每次循环迭代都会执行对 `msg.value` 的处理，这可能导致不必要的 gas 消耗，并且在某些情况下可能引发意外的问题。通常，最好在循环之外处理 `msg.value`。

## 描述一个函数 `calldata`，该函数接受一个动态长度的 uint128 数组作为参数，当传递 `uint128[1,2,3,4]` 作为参数时会发生什么

```solidity
function exampleFunction(uint128[] calldata dynamicArray) external {
    // 函数逻辑，可以使用 dynamicArray
}
```

这个函数 `exampleFunction` 接受一个动态长度的 `uint128` 数组作为 `calldata` 参数。当传递 `uint128[1,2,3,4]` 作为参数时，`dynamicArray` 将包含这个数组，函数可以访问并处理这个数组的内容。

## 为什么严格的不相等比较比 ≤ 或 ≥ 更节省 gas？额外的操作码是什么？

在 EVM 中，严格不相等比较 `!=` 相较于 `≤` 或 `≥` 操作更为简单，因此更节省 gas。额外的操作码是 `ISZERO`，它用于检查两个值是否不相等。严格不相等比较的字节码更短，因此执行时消耗的 gas 更少。

## 如果代理调用一个实现，并且在被调用的函数中实现自毁，会发生什么？

如果代理调用的实现合约中包含了自毁（self-destruct）操作，只有实现合约会被销毁，代理合约的存储和代码不会受到影响。代理合约仍然存在，并继续执行，只是它现在调用的实现合约已被销毁。

## 变量作用域和堆栈深度之间有什么关系？

变量的作用域决定了变量的可见范围，而堆栈深度则指的是在执行合约时，调用的函数和变量被存储在堆栈中的深度。深度较深的函数调用会在堆栈上占用更多的空间。在 Solidity 中，局部变量通常存储在栈上，而状态变量存储在存储中。深度的增加可能导致堆栈溢出，因此在设计合约时需要注意控制调用深度。

## 访问列表交易是什么？

访问列表交易是一种通过将交易与访问控制列表（ACL）结合使用的机制，来限制对智能合约的访问权限。ACL 中列出了允许或禁止执行某个函数的地址列表。这样，只有在访问列表中的地址才能成功调用相应的函数，实现了更灵活的权限控制。

## 如何使用 mload 操作码终止执行？

`mload` 操作码用于从内存中加载数据，不能直接用于终止执行。终止执行通常使用 `revert` 操作码。要在 Solidity 中使用 `revert` 终止执行，可以使用以下语句：

```solidity
assembly {
    revert(0, 0)
}
```

这会触发一个回滚，回退到调用者，并将消息设为零长度。

## 在代理的上下文中，什么是信标（beacon）？

在代理的上下文中，"信标" 通常指的是包含实际实现的合约地址。代理合约通过调用信标上的代码来执行功能。信标的地址可以根据需要更改，而代理合约保持不变，实现了升级合约的目的。

## 为什么在进行治理投票之前需要对余额进行快照？

在进行治理投票之前对余额进行快照是为了确保投票的公平性和一致性。通过在快照时记录每个地址的余额，可以防止在投票期间地址的余额发生变化，从而确保投票结果基于相同的权益。

## 如何执行一个不需要用户支付 gas 的交易？

执行不需要用户支付 gas 的交易通常通过代付的方式实现。外部账户（通常是 dApp 或服务提供商）预先支付了 gas 费用，然后以代付的形式调用用户的交易。这样用户无需自己支付 gas 费用，但执行交易的外部账户需要足够的资金来支付 gas。

## 在 Solidity 中，不使用汇编，如何获取 calldata 的函数选择器？

在 Solidity 中，可以使用 `bytes4` 类型的 `msg.sig` 来获取 calldata 的函数选择器，例如：

```solidity
function getFunctionSelector() public pure returns (bytes4) {
    return msg.sig;
}
```

这将返回调用函数的函数选择器，不需要使用汇编。

## 以太坊地址是如何派生的？

以太坊地址是由公钥通过椭圆曲线加密算法派生而来的。具体而言，地址是公钥经过 Keccak-256 哈希算法取前 20 字节（40 个十六进制字符）的结果。

## 什么是元代理标准？

"元代理标准" 并非通用术语，可能是指一种支持代理合约升级的标准或模式。代理模式允许升级合约代码而不改变合约地址，提供了灵活性和可维护性。

## 如果 try catch 调用一个不会回滚的合约，但在 try 块内发生回滚，会发生什么？

即使在 try 块内发生回滚，try catch 结构不会捕获这个回滚，因为 Solidity 的 try catch 只捕获外部调用中的回滚。在这种情况下，回滚会继续传播，影响整个交易。

## 如果用户调用代理并使代理进行 delegatecall 到 A，A 从其角度来看，msg.sender 是谁？从 B 的角度来看，msg.sender 是谁？从代理的角度来看，msg.sender 是谁？

- 从 A 的角度：`msg.sender` 是代理的地址。
- 从 B 的角度：`msg.sender` 是 A 的地址。
- 从代理的角度：`msg.sender` 是用户调用代理的地址。

## 为什么大量合约字节码以 6080604052 开头？这个字节码序列是做什么的？

`6080604052` 是 Solidity 编译器生成的合约字节码的开头部分，代表了合约的初始化。这个序列可能包含了合约的元信息、构造函数等。具体内容取决于合约的编写和编译。

## Uniswap V3 如何确定流动性区间的边界？

Uniswap V3 使用 NFT（非同质化代币）作为流动性提供者在特定范围内提供流动性。每个 NFT 代表一个特定价格范围内的流动性，其边界由价格范围的上下限决定。通过动态调整这些 NFT 的范围，Uniswap V3 确定了不同价格区间内的流动性。

## 无风险利率是什么？

无风险利率是指在没有风险的情况下，投资者可获得的利率。它通常用于金融领域，作为基准利率，用于计算其他投资的相对收益。无风险利率通常基于政府债券等低风险金融工具的利率。

## 当一个合约通过 call、delegatecall 或 staticcall 调用另一个合约时，它们之间如何传递信息？

- **call：** 通过 `call` 进行调用时，被调用合约的代码会在新的执行环境中运行，原合约的状态和上下文不受影响。`call` 的返回值包括执行结果和数据。

- **delegatecall：** 使用 `delegatecall` 进行调用时，被调用合约的代码在调用合约的上下文中执行，共享相同的存储空间。这样，被调用合约可以访问调用合约的状态。

- **staticcall：** `staticcall` 与 `call` 类似，但不允许被调用合约修改状态，仅用于读取数据。

## 内存中的 bytes 和 bytes1[] 之间有什么区别？

在 Solidity 中，`bytes` 是动态字节数组，而 `bytes1[]` 是固定大小的字节数组数组。具体区别如下：

- **bytes：** 动态字节数组，可以动态改变大小，通常用于存储不定长度的数据。
- **bytes1[]：** 固定大小的字节数组数组，每个元素都是一个字节。大小固定，不可动态调整。

## 以太坊预编译合约的地址是什么？

以太坊预编译合约的地址是 0x0000000000000000000000000000000000000001。预编译合约是在以太坊中预先部署的一些常用合约，如 ECDSA 验证等，用于提供底层功能和优化。

## 当函数数量超过 4 个时，Solidity 如何管理函数选择器？

Solidity 使用一种称为函数选择器哈希表的机制，将函数选择器映射到实际函数的位置。当函数数量超过 4 个时，Solidity 会使用哈希表来查找函数的位置，而不是简单地按顺序查找。

## 如果对一个合约进行委托调用，而该合约又对另一个合约进行委托调用，那么在代理合约、第一个合约和第二个合约中，msg.sender 是谁？

- 在**代理合约**中，`msg.sender` 是最初调用的用户的地址。
- 在**第一个合约**中，`msg.sender` 是代理合约的地址。
- 在**第二个合约**中，`msg.sender` 仍然是代理合约的地址，因为委托调用并不改变 `msg.sender`。

## 如果有的话，ABI 编码在 calldata 和 memory 之间有何不同？

在 Solidity 中，ABI 编码是在 `calldata` 中进行的。`calldata` 是一个特殊的区域，用于存储调用函数时传递的参数和数据。相比之下，`memory` 用于在合约执行过程中存储动态分配的数据，而不是用于 ABI 编码。ABI 编码将数据格式化为按照规定的格式排列的字节序列，以便与外部进行通信。

## uint64 和 uint256 在 calldata 中的 ABI 编码有何不同？

在 ABI 编码中，`uint64` 和 `uint256` 的编码方式取决于它们在函数参数中的位置。

- **`uint64`：** 在 `calldata` 中，`uint64` 将被编码为占据 8 个字节的数据。

- **`uint256`：** `uint256` 则会占据 32 个字节的空间。

ABI 编码会确保按照规定的格式将数据编码为字节序列，以便与外部进行通信。

## 什么是只读重入？

只读重入是一种特殊的重入攻击，攻击者在重入调用中仅进行读取操作，不修改状态。这可能使得重入攻击更难被检测，因为只读操作在调用过程中不会触发异常或回滚。攻击者可能通过反复读取状态来实现潜在的恶意行为，而不被触发任何异常。

## 从不受信任的智能合约调用中读取（内存）字节数组的安全考虑是什么？

当从不受信任的智能合约调用中读取字节数组时，需要注意以下安全考虑：

- **边界检查：** 确保进行足够的边界检查，防止读取超出数组范围的数据。

- **清零敏感信息：** 在使用完敏感信息后，立即清零或销毁，以防止泄露敏感数据。

- **避免循环：** 避免在循环中进行读取操作，以免引起 gas 耗尽攻击。

- **使用 view 函数：** 如果可能，将读取操作封装在 `view` 函数中，以确保不会修改状态。

## 如果部署一个空的 Solidity 合约，在区块链上会有什么字节码，如果有的话？

如果部署一个空的 Solidity 合约，合约的字节码将包含合约创建和初始化的操作码，但不会包含实际的合约逻辑。这是因为空合约没有定义任何函数或状态变量。字节码中的初始化部分通常包括一些用于设置合约的基本结构的操作。

## 以太虚拟机如何定价内存使用？

以太虚拟机中的内存使用是通过 gas 进行定价的。每个 `MSTORE` 和 `MLOAD` 操作都会消耗 gas，而且 gas 的消耗是与写入或读取的字节数成比例的。因此，更多的内存使用将导致更高的 gas 成本。

## 智能合约的元数据部分存储了什么？

智能合约的元数据部分存储了合约的一些基本信息，包括合约的编译版本、作者、许可证信息等。这些信息可以通过合约的元数据在区块链上找到，提供了对合约的更多描述性信息。

## 从 MEV 的角度来看，什么是叔块攻击？

叔块攻击是一种攻击方法，攻击者通过在先前的区块中包含叔块（Uncle Block，也称为“ommer”），试图影响区块的最终确定性，从而获得更大的矿工奖励。攻击者可能会在自己的区块中包含对父区块的合法叔块，以争取更高的奖励份额。

## 如何进行签名篡改攻击（malleability attack）？

签名篡改攻击是指攻击者在签名的过程中修改签名，而不改变原始消息，从而导致相同的消息具有不同的签名。这可能会引发一系列问题，如恶意重新提交交易等。防范签名篡改攻击的方法之一是使用合适的签名方案，如 ECDSA 的可抵抗篡改版本。

## 在什么情况下，具有前导零的地址可以节省 gas，以及为什么？

具有前导零的地址在以太坊中会节省 gas，因为在 EVM 中，地址被视为一个 20 字节的数值。如果地址具有前导零，它的字节数目较少，可以通过更短的字节序列来表示，从而减少了 gas 消耗。这种优化通常用于合约创建等操作。

## payable(msg.sender).call{value: value}("")和 msg.sender.call{value: value}("")之间有什么区别？

- **`payable(msg.sender).call{value: value}("")`：** 这是使用 `payable` 转换将 `msg.sender` 转为 `payable` 类型，然后调用 `call` 函数。这样做是为了确保 `msg.sender` 具有接收以太的能力。如果 `msg.sender` 不是 `payable`，这将导致编译错误。

- **`msg.sender.call{value: value}("")`：** 这是直接调用 `call` 函数，假定 `msg.sender` 已经是 `payable` 类型。这样做的前提是你确定 `msg.sender` 可接收以太。

两者的本质区别在于对 `msg.sender` 类型的处理，第一个方法使用 `payable` 转换以确保 `msg.sender` 可接收以太。

## 一个字符串占用多少个存储槽？

在 Solidity 中，字符串（`string`）的长度不同，其占用的存储槽数量也不同。字符串的存储成本由其长度决定。每个存储槽可以存储 32 字节的数据，字符串的长度除以 32（向上取整）即为字符串占用的存储槽数量。

## Solidity 编译器中的 --via-ir 功能是如何工作的？

`--via-ir` 是 Solidity 编译器的一个选项，用于将 Solidity 源代码编译为中间表示（Intermediate Representation，IR）。该选项使得用户可以通过查看 IR 来更深入地了解 Solidity 编译过程中的中间步骤，帮助调试和分析合约。

## 函数修饰符是从右到左调用还是从左到右调用，还是不确定的？

函数修饰符是从左到右调用的。在 Solidity 中，函数修饰符按照它们在函数声明中出现的顺序依次执行。

## 如果对一个合约进行委托调用，而执行了指令 CODESIZE，将返回哪个合约的大小？

在委托调用中执行 CODESIZE 指令时，返回的是被调用合约（delegatecall 的目标合约）的大小，而不是委托调用的合约。

## 为什么 ECDSA 对哈希而不是任意 bytes32 进行签名很重要？

ECDSA（椭圆曲线数字签名算法）对哈希进行签名是为了安全性和性能。对整个数据进行签名可能会导致潜在的安全漏洞，而对哈希进行签名能够降低签名的复杂性，并更好地适应椭圆曲线签名算法的特性。同时，使用哈希减少了签名时需要传输和处理的数据量，提高了性能。

## 描述符号操作测试 (symbolic manipulation testing) 是如何工作的。

符号操作测试是一种测试方法，它通过模拟执行（symbolic execution）的方式对智能合约进行测试。在符号执行中，不使用具体的输入值，而是使用符号表示的变量进行执行路径的探索。这样可以发现在不同的输入条件下，程序的执行路径和状态的变化。

## 复制内存区域的最有效方式是什么？

在 Solidity 中，`memcpy` 函数可用于复制内存区域。最有效的方式是使用内联汇编指令 `assembly` 并调用 EVM 的 `mstore` 操作码。以下是一个简单的例子：

```solidity
function memcpy(uint dest, uint src, uint len) public pure {
    // 使用 inline assembly 复制内存区域
    assembly {
        // 将 src 复制到 dest，长度为 len
        for {
            let i := 0
        } lt(i, len) {
            i := add(i, 32)
        } {
            mstore(add(dest, i), mload(add(src, i)))
        }
    }
}
```

这段代码使用 `assembly` 将源地址 `src` 的内容复制到目标地址 `dest`，并复制的长度为 `len` 字节。

## 如何在链上验证另一个智能合约是否触发了一个事件，而不使用预言机？

在链上验证智能合约是否触发了一个事件可以通过读取日志（Log）来实现。在 Solidity 中，你可以使用 `getLogs` 函数来获取指定合约地址的事件日志，然后检查日志中是否包含特定的事件和参数。

```solidity
// 示例：验证事件触发
function verifyEvent(address contractAddress, uint expectedValue) public view returns (bool) {
    // 获取指定合约地址的日志
    bytes32[] memory topics = new bytes32[](1);
    topics[0] = keccak256("EventName(uint256)");

    // 获取合约地址的日志
    bytes memory data = abi.encodePacked(contractAddress);
    uint fromBlock = block.number - 100;  // 适当选择起始块

    // 调用 getLogs 函数
    bytes memory logs = address(this).staticcall(abi.encodeWithSignature("getLogs(address,uint,uint,bytes32[])", contractAddress, fromBlock, block.number, topics));

    // 解析日志，检查是否包含期望的事件和参数
    for (uint i = 0; i < logs.length; i += 32) {
        if (bytes32(expectedValue) == abi.decode(logs, (bytes32))) {
            return true;  // 验证通过
        }
    }

    return false;  // 未找到匹配的日志
}
```

请注意，这是一个简化的示例，实际中需要根据具体的事件结构和参数进行调整。

## 当调用 selfdestruct 时，以太何时转移？智能合约的字节码何时被擦除？

当调用 `selfdestruct` 时，以太会在同一交易中被直接发送到指定的地址。这意味着合约的余额将被转移到目标地址。

合约的字节码在调用 `selfdestruct` 后，并不会立即从区块链上删除。Solidity 不会擦除合约的字节码，而是留下一个空的合约，其地址保留在区块链上。这也就是为什么可以通过 Etherscan 或其他区块链浏览器查看已销毁合约的元数据信息。

## 在什么条件下，OpenZeppelin 的 Proxy.sol 会覆盖自由内存指针？为什么这样做是安全的？

在使用 OpenZeppelin 的 Proxy.sol 时，如果合约的存储槽被重新分配，可能会覆盖自由内存指针。

这种情况通常发生在升级合约时，新的实现合约的存储槽结构与旧的不同。

这样做是安全的，因为 Proxy.sol 中的存储槽分配和存储槽指针更新是原子的。在 OpenZeppelin 的实现中，使用 `SSTORE` 操作码进行存储槽分配，确保在同一交易中所有存储槽的分配都成功，然后更新指针。

此过程的原子性确保了在升级合约的过程中不会因为存储槽被分配的不一致而导致问题。

## 为什么 Solidity 废弃了 "years" 关键字？

Solidity 废弃 "years" 关键字是因为时间单位的定义相对模糊，不同的上下文中可能有不同的解释，导致理解和使用上的混淆。因此，为了避免潜在的歧义，Solidity 团队决定废弃 "years" 关键字。建议使用更明确和统一的时间单位，例如 "seconds"、"minutes"、"hours"、"days" 和 "weeks"。

## verbatim 关键字的作用是什么，以及它可以在哪里使用？

`verbatim` 关键字是 Solidity 中的一个注释修饰符，用于告诉编译器将接下来的注释内容原样包含在生成的 ABI（Application Binary Interface）文档中，而不进行任何解析或格式化。它允许开发者在 ABI 文档中包含特定格式的文本或标记。

`verbatim` 关键字可以在合约的注释块中使用，主要用于增强 ABI 文档的可读性和格式化。例如：

````solidity
/// @dev This function does something important.
/// @param x The input parameter.
/// @verbatim
/// Example:
/// ```
/// contract.myFunction(42);
/// ```
/// @endverbatim
function myFunction(uint x) external {
    // 函数实现
}
````

在上述例子中，`@verbatim` 和 `@endverbatim` 之间的注释内容将以原样包含在生成的 ABI 文档中。

## 在调用另一个智能合约时可以转发多少 gas？

在 Solidity 中，使用 `external` 函数调用另一个智能合约时，可以使用 `gas` 关键字显式指定转发的 gas 数量。如果不显式指定，Solidity 将默认转发所有可用的 gas。

示例：

```solidity
contract Caller {
    function callOtherContract(address otherContract) external {
        // 调用另一个合约，并转发所有可用的 gas
        (bool success, ) = otherContract.call{gas: gasleft()}(abi.encodeWithSignature("someFunction()"));
        require(success, "Call failed");
    }
}
```

在上述例子中，通过 `gas: gasleft()` 显式指定了转发的 gas 数量，它等于当前剩余的 gas 数量。

## 存储 -1 的 int256 变量在十六进制中是什么样子的？

存储 -1 的 `int256` 变量在十六进制中表示为 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF。这是因为 Solidity 中的 `int256` 是采用补码表示的，-1 在补码中用全 1 表示。

## signextend 操作码有什么用？

`signextend` 操作码用于对有符号整数进行符号扩展。具体来说，`signextend` 取两个参数：一个是存储在栈顶的有符号整数，另一个是扩展的位数。它将有符号整数的最高有效位进行扩展，以填充栈顶元素的其他位。

示例：

```assembly
// 将有符号整数 0xFFFF 扩展为 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
signextend(0x0, 15)
```

在上述例子中，`signextend` 将 `0xFFFF` 扩展为 `0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF`。

## 为什么 calldata 中的负数会消耗更多的 gas？

在 Solidity 中，对于 calldata 中的负数，其编码方式可能涉及到额外的字节，因此消耗更多的 gas。负数在 calldata 中的编码采用补码形式，如果最高有效位是 1，则需要额外的字节来表示这个负数。

这与正数不同，正数通常可以紧凑地编码，因为它们的最高有效位为 0，不需要额外的字节。但负数由于需要表示负号，可能需要额外的字节进行扩展。

## 什么是 zk-friendly 哈希函数，它与非 zk-friendly 哈希函数有何不同？

"zk-friendly" 意指“零知识友好”（zero-knowledge friendly）。在零知识证明（Zero-Knowledge Proof）的背景下，zk-friendly 哈希函数具有特定的性质，能够更好地适应零知识证明系统的需求。

通常来说，zk-friendly 哈希函数应该满足零知识证明的一些特定性质，例如：

1. **可扩展性（Collisions Resilience）**：难以在相同的哈希值上生成不同的输入。
2. **难以预测性（Pseudorandomness）**：难以从哈希输出推断出输入的任何信息。
3. **扭曲性（Gap-Hardness）**：哈希输出的范围应该是难以通过计算推断的，确保对输出空间的枚举不会暴露太多关于输入的信息。

与非 zk-friendly 哈希函数相比，zk-friendly 哈希函数更强调在零知识证明环境下的安全性和性能。

## 在零知识的背景下，什么是 nullifier，它的用途是什么？

在零知识证明系统中，nullifier 是一种用于保护用户隐私的重要概念。在匿名性货币和零知识证明的应用中，nullifier 主要用于防止“双花”攻击和识别交易参与者。

Nullifier 是一种可以证明某个特定加密货币交易已经被花费的信息。

# 智能合约常见攻击方式

智能合约常见的攻击方式包括但不限于以下几种：

1. **重入攻击（Reentrancy Attack）**：

   - 攻击者利用合约调用的过程中调用另一个合约，并在另一个合约的执行过程中再次调用原始合约，可能导致意外的重复执行。

2. **溢出和下溢攻击**：

   - 整数溢出（Integer Overflow）和下溢是由于数值超出合约数据类型的表示范围而引起的问题，攻击者可能通过溢出或下溢来获得非法利益。

3. **代理合约攻击**：

   - 攻击者利用合约的升级机制或代理合约进行攻击，可能导致不受控制的更改或执行。

4. **交易顺序依赖攻击（Front-Running）**：

   - 攻击者在知道其他用户即将执行的交易时，先执行相同的操作以获取不正当利益。

5. **悬挂污染攻击（Gas Token Attack）**：

   - 攻击者利用预先购买的廉价 gas 代币，在需要高 gas 费用的时候将其推高，使其它用户在执行交易时支付更高的 gas 费用。

6. **短地址攻击**：

   - 攻击者通过在输入数据中使用不足 64 位的地址，导致 EVM 在处理时产生额外的费用，从而欺骗合约。

7. **无限循环攻击**：

   - 攻击者创建一个包含无限循环的合约，导致交易无法正常结束，浪费 gas。

8. **合约注入攻击**：

   - 攻击者通过在合约的存储位置中存放合约地址，使其被认为是合约的一部分，从而执行未预期的代码。

9. **伪随机数攻击**：

   - 合约中使用不安全的随机数生成算法，攻击者可能通过预测或控制随机数的生成来获得不正当利益。

10. **合约灰度攻击（Honeypot）**：
    - 攻击者通过部署看似有漏洞的合约来吸引其他用户投入资金，从而实施欺诈。

这些攻击方式强调了智能合约开发中需要谨慎处理输入、避免不安全的操作、使用可靠的随机数生成等最佳实践。安全审计和合约测试是确保合约安全性的重要手段。

- [https://solidity-by-example.org/hacks/re-entrancy/
  ](https://solidity-by-example.org/hacks/re-entrancy/)

# 以太坊开发文档

- [以太坊开发文档](https://ethereum.org/zh/developers/docs)
